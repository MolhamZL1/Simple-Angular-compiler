package Code_Generation;

import SymbolTable.Component.ComponentSymbol;
import SymbolTable.Component.ComponentsSymboleTable;
import utils.FileManager;

import java.util.Map;

/**
 * Emits a single runtime JS file (app.js) that:
 *  - exposes APP_DATA (from JSON you pass)
 *  - embeds COMPONENTS templates (read from SymbolTable)
 *  - provides a tiny runtime to expand {{ }}, *ngFor, [ngClass], [ngStyle], [disabled]
 *  - converts (click)="..." into data-action="..." and wires a delegated click handler
 */
public class JsEmitter {

    private final ComponentsSymboleTable table;

    public JsEmitter(ComponentsSymboleTable table) {
        this.table = table;
    }

    private static String jsEscapeBackticks(String s) {
        if (s == null) return "";
        // escape backticks and closing </script> to avoid breaking the string in HTML context
        return s
                .replace("\\", "\\\\")
                .replace("`", "\\`")
                .replace("</", "<\\/")
                .replace("\r", "")
                .replace("\n", "\\n");
    }

    private static String normalizeTemplate(String tpl) {
        if (tpl == null) tpl = "";
        // 1) حول (click)="expr" -> data-action="expr"
        tpl = tpl.replaceAll("\\(click\\)\\s*=\\s*\"([^\"]+)\"", "data-action=\"$1\"");
        // 2) ممكن تضيف تحويلات إضافية لاحقاً (change/input …)
        return tpl;
    }

    /** Writes dist/app.js with runtime + components + bootstrap code. */
    public void emit(String outJsPath, String rootComponentSelector, String initialDataJson) {
        StringBuilder sb = new StringBuilder(64_000);

        sb.append("// === Auto-generated by CodeGen ===\n");

        // 1) App data (JSON you pass from your generator)
        if (initialDataJson == null || initialDataJson.isBlank()) {
            initialDataJson = "{}";
        }
        sb.append("const APP_DATA = ").append(initialDataJson).append(";\n\n");

        // 2) COMPONENTS from SymbolTable (template + optional style path)
        sb.append("const COMPONENTS = {\n");
        boolean first = true;
        for (Map.Entry<String, ComponentSymbol> e : table.getSymbols().entrySet()) {
            final String selector = e.getKey();
            final ComponentSymbol sym = e.getValue();

            String tpl = FileManager.readFile(sym.getTemplatePath());
            tpl = normalizeTemplate(tpl);
            String tplEsc = jsEscapeBackticks(tpl);

            String stylePath = sym.getStylePath() != null ? sym.getStylePath() : "";

            if (!first) sb.append(",\n");
            first = false;
            sb.append("  `").append(selector).append("`: { ")
                    .append("template: `").append(tplEsc).append("`, ")
                    .append("stylePath: `").append(jsEscapeBackticks(stylePath)).append("` ")
                    .append("}");
        }
        sb.append("\n};\n\n");

        // 3) Tiny runtime (interpolate, bindings, *ngFor, custom tags, event wiring)
        sb.append("""
/** {{ expr }} */
function interpolate(html, ctx){
  return html.replace(/\\{\\{\\s*([^}]+)\\s*\\}\\}/g, (_, expr) => {
    try { with (ctx) { const v = eval(expr); return (v ?? '') + ''; } }
    catch { return ''; }
  });
}

/** Applies [disabled], [ngClass], [ngStyle] after nodes are in the DOM */
function applyPropertyBindings(root, ctx){
  // [disabled]
  root.querySelectorAll('[\\\\[disabled\\\\]]').forEach(el => {
    const expr = el.getAttribute('[disabled]');
    let val = false; try { with(ctx){ val = !!eval(expr); } } catch {}
    if (val) el.setAttribute('disabled',''); else el.removeAttribute('disabled');
    el.removeAttribute('[disabled]');
  });

  // [ngClass]
  root.querySelectorAll('[\\\\[ngClass\\\\]]').forEach(el => {
    const expr = el.getAttribute('[ngClass]');
    let res = ''; try { with(ctx){ res = eval(expr); } } catch {}
    if (typeof res === 'string' && res.trim()) {
      el.className = (el.className + ' ' + res).trim();
    }
    el.removeAttribute('[ngClass]');
  });

  // [ngStyle]
  root.querySelectorAll('[\\\\[ngStyle\\\\]]').forEach(el => {
    const expr = el.getAttribute('[ngStyle]');
    let obj = {}; try { with(ctx){ obj = eval('(' + expr + ')'); } } catch {}
    if (obj && typeof obj === 'object') {
      for (const k of Object.keys(obj)) el.style[k] = obj[k];
    }
    el.removeAttribute('[ngStyle]');
  });
}

/** Expands *ngFor="let x of arr" */
function expandNgFor(html, ctx){
  const wrap = document.createElement('div');
  wrap.innerHTML = html;

  wrap.querySelectorAll('*[*ngFor]').forEach(node => {
    const dir = node.getAttribute('*ngFor'); // e.g. let product of productItems
    const m = /let\\s+(\\w+)\\s+of\\s+([^;]+)/.exec(dir);
    if (!m) { node.removeAttribute('*ngFor'); return; }
    const varName = m[1];
    const arrExpr = m[2];

    let arr = [];
    try { with (ctx) { arr = eval(arrExpr) || []; } } catch {}

    const parent = node.parentNode;
    const templateHtml = node.outerHTML.replace(/\\s*\\*ngFor="[^"]*"/, '');

    for (let i = 0; i < arr.length; i++) {
      const item = arr[i];
      const childCtx = Object.create(ctx);
      childCtx[varName] = item;
      childCtx.index = i;

      // Run interpolate before insertion so attributes are filled
      const piece = interpolate(templateHtml, childCtx);

      const temp = document.createElement('div');
      temp.innerHTML = piece;
      const el = temp.firstElementChild;
      if (!el) continue;

      parent.insertBefore(el, node);
      // bindings after insertion
      applyPropertyBindings(el, childCtx);
    }
    parent.removeChild(node);
  });

  return wrap.innerHTML;
}

/** Recursively expands <app-xyz> using COMPONENTS */
function expandCustomTags(html, ctx){
  const re = /<(app-[a-z0-9\\-]+)([^>]*)>([\\s\\S]*?)<\\/\\1\\s*>|<(app-[a-z0-9\\-]+)([^>]*)\\s*\\/>/ig;
  return html.replace(re, (m, sel1, attrs1, inner, sel2, attrs2) => {
    const selector = sel1 || sel2;
    const comp = COMPONENTS[selector];
    if (!comp) return m;

    let out = comp.template;
    out = expandCustomTags(out, ctx); // depth-first
    out = expandNgFor(out, ctx);
    out = interpolate(out, ctx);
    return out;
  });
}

/** Delegated click handling for data-action="fn(args)" */
function wireClickDelegation(root, ctx){
  root.addEventListener('click', (e) => {
    const t = e.target.closest('[data-action]');
    if (!t) return;
    const expr = t.getAttribute('data-action');
    try { with (ctx) { eval(expr); } } catch (err) { console.error('action error:', err); }
  });
}

/** Main render */
function renderApp(rootSelector, rootComponentSelector, ctx){
  const rootEl = document.querySelector(rootSelector);
  if (!rootEl) return;

  const comp = COMPONENTS[rootComponentSelector];
  if (!comp) { rootEl.innerHTML = ''; return; }

  let html = comp.template;
  html = expandCustomTags(html, ctx);
  html = expandNgFor(html, ctx);
  html = interpolate(html, ctx);

  rootEl.innerHTML = html;
  applyPropertyBindings(rootEl, ctx);
  wireClickDelegation(rootEl, ctx);
}
""");

        // 4) Bootstrap code
        String root = (rootComponentSelector == null || rootComponentSelector.isBlank())
                ? "app-root" : rootComponentSelector;

        sb.append("\n// === Bootstrap ===\n");
        sb.append("document.addEventListener('DOMContentLoaded', () => {\n");
        sb.append("  const ctx = Object.assign({}, APP_DATA);\n");
        sb.append("  // Example methods: you can generate from SymbolTable if you track methods\n");
        sb.append("  ctx.cart = new Map();\n");
        sb.append("  ctx.addToCart = (id) => {\n");
        sb.append("    const key = String(id);\n");
        sb.append("    ctx.cart.set(key, (ctx.cart.get(key) || 0) + 1);\n");
        sb.append("    if (typeof ctx.updateCartBadge === 'function') ctx.updateCartBadge();\n");
        sb.append("  };\n");
        sb.append("  ctx.updateCartBadge = () => {\n");
        sb.append("    const b = document.querySelector('.badge.rounded-pill.bg-danger');\n");
        sb.append("    if (!b) return;\n");
        sb.append("    let tot = 0; for (const v of ctx.cart.values()) tot += v; b.textContent = String(tot);\n");
        sb.append("  };\n");
        sb.append("  renderApp('#app', '").append(root).append("', ctx);\n");
        sb.append("});\n");

        // write file
        FileManager.createFile(outJsPath);
        FileManager.writeFile(outJsPath, sb.toString());
    }
}
